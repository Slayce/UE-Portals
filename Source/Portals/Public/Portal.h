// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Portal.generated.h"

class UPortalSceneCapture;
class UTextureRenderTarget2D;

// Struct used to store all information needed to render a texture
USTRUCT(BlueprintType)
struct FTextureToRender {
   GENERATED_BODY()

public:
   FTextureToRender() : texture(nullptr), is_mirror(false), weight(0.f) {};
   FTextureToRender(FTextureToRender&& other) noexcept;
   FTextureToRender(const FTextureToRender& other) noexcept;
   FTextureToRender& operator=(FTextureToRender&& other) noexcept;
   FTextureToRender& operator=(const FTextureToRender& other) noexcept;

   UPROPERTY(BlueprintReadOnly)
   const UTexture* texture;

   UPROPERTY(BlueprintReadOnly)
   bool is_mirror;

   UPROPERTY(BlueprintReadOnly)
   float weight;
};


UCLASS()
class PORTALS_API APortal : public AActor
{
   GENERATED_UCLASS_BODY()

public:
   // ---- Getters & Setters ---- //

   void SetActive(bool is_active) { m_is_active = is_active; }

   virtual void SetSceneCaptures() PURE_VIRTUAL(APortal::SetSceneCaptures,);
   
   TArray<UPortalSceneCapture*> GetSceneCaptures() { return m_scene_captures; }

   // Check if the portal has been rendered but the "parent" portal has not captured it yet
   // In that case, we want to keep its state and thus create a copy
   bool IsRendererButNotCaptured() const { return m_is_renderer_but_not_captured; }
   
   void SetIsRendererButNotCaptured(bool is_renderer_but_not_captured) { m_is_renderer_but_not_captured = is_renderer_but_not_captured; }

   // Get all 4 mesh vertices and compute the middle point and store them for quicker access
   void LoadMeshVertices() const;

   const TArray<FVector>* GetMeshVertices() const;
   FVector GetMiddlePoint() const { return m_middle_point; }

   // --------------------------- //

   FPlane GetPortalPlane() const { return FPlane(GetActorLocation(), GetActorForwardVector()); }

   // Generate texture depending on visible portals (recursive)
   void Render(const FTransform watched_actor_transform, const FMatrix& projection_matrix, unsigned int depth);

   // Updates all SceneCaptures of the portal
   void UpdateCaptures(const FTransform& watched_actor_transform, const FMatrix& projection_matrix);

   // Gather textures generated by SceneCaptures and send them to BluePrint to be applied on the mesh
   void UpdatePortalTexture();

   UFUNCTION(BlueprintCallable)
      static int GetActivePortalDistance() { return m_ACTIVE_PORTAL_DISTANCE; }

   // -------- BP events -------- //

   // Blueprint event that sets the material parameters to apply the textures passed as parameters
   UFUNCTION(BlueprintImplementableEvent, Category = "Portal")
   void SetRTT(const TArray<FTextureToRender>& textures_to_render);

   // Blueprint event that is called every tick
   UFUNCTION(BlueprintImplementableEvent, Category = "Portal")
   void ForceTick();


protected:
   virtual void BeginPlay() override;

   UPortalSceneCapture* CreateDefaultSceneCapture();

   static void SetDefaultSceneCaptureParameters(UPortalSceneCapture* inout_scene_capture);

   UFUNCTION(BlueprintCallable)
   static bool IsPointInsideBox(FVector point, UBoxComponent* box);

   // ------------------------------------- //

   UPROPERTY(VisibleAnywhere, Category = "Portal|Mesh")
   UStaticMeshComponent* m_portal_mesh;

   // Shortcuts to prevent loading every time, but mutable because it's just a shortcut
   mutable TArray<FVector> m_vertices;
   mutable FVector m_middle_point;

   UPROPERTY(BlueprintReadOnly)
   bool m_is_active;

   // Scene captures linked to the portal. Maximum 5 supported
   TArray<UPortalSceneCapture*> m_scene_captures;

private:
   // If set to true, we need to make sure the textures generated by the SceneCaptures are not overwritten
   bool m_is_renderer_but_not_captured;

   static const unsigned int m_MAX_RENDER_DEPTH = 4;

   static const unsigned int m_ACTIVE_PORTAL_DISTANCE = 10000;
};
